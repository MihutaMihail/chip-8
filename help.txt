/// Chip 8 Specs \\\
//
// --- Memory [4096]byte
// Chip-8 has 4096 memory locations
//
// --- Registers [16]byte
// Used to store values ranging from V0 to VF. These registers are 8 bits (byte) long and are used to 
// store data for future use.
//
// --- Pc uint16.
// Program Counter. Keeps track of the memory addresses that are currently executed instruction
// When jumps are occured, the PC can be modified to redirect the flow of the program and its next instructions
//
// --- I uint16
// Index Register. Used to store values that involve memory operations
//
// --- Stack [16]uint16
// The stack has 16 levels of nesting used for managing the flow of execution and handle subroutines
// (sequence of program instructions)
//
// --- Sp byte
// Stack Pointer. Keep track of current nesting level
// 
// --- COpcode opcode
// Represents the current opcode. The opcode is needed to execute the correct instruction.
// Once the current opcode instruction is executed, the next opcode is loaded
// 
// --- Instructions map[uint16]func(){}
// Key : opcode
// Value : function containing the code needed to execute the respective instruction
---------------------------------------------------------------------------------------------------------------------------
/// Extract nibble \\\
//
// To decode CHIP-8 opcodes, we'll need to isolate the nibble (the 4 most important bits) which represents the instruction part
//
// Here's the code :
//
//\\    (uint16(oc) & uint16(0xF000)) >> 12 
//
// We use the hexadecimal value 0xF000 as a bitmask (1111000000000000)
// This will effectively set all bits to 0 except the highest 4 bits of the opcode
// This only works because it is an AND operation. The 0 would just nullify you could say all the these bites while the 1
// will make sure that the correct value is being represented by the bites
// After the operation, our opcode will still be a 16-bit value but this time we isolated the only part that we need.
// What we need to do is shift the nibble all the way down (to the right) to isolate them (least significant bits)
---------------------------------------------------------------------------------------------------------------------------
/// Extract parameters \\\
//
// Extracting the parameters 0x1NNN (the NNN) is pretty much the same thing as the nibble. 
// We'll need to use a different bitmask to set the nibble to 0. No shift needed
// Here's the code : 
//
//\\    uint16(oc) & uint16(0x0FFF) 
---------------------------------------------------------------------------------------------------------------------------
/// Bitmask \\\
// 
// From what I can see 0x000F sets the 12 most important bits to 0 (because of the 000) while 
// retaining the least important bits (because of the F)
// So to get the X parameters use the bitmask 0x0F00
// And for Y parameters use the bitmask 0x00F0
// This is because X is the second value in the opcode while Y is the third so the F is on
// the second / third value respectivelyd
---------------------------------------------------------------------------------------------------------------------------
/// GetOpcodeInstruction() \\\
//
// Here's the code :
//
//\\ func (oc opcode) GetOpcodeInstruction() uint16 {
//\\	switch (uint16(oc) & uint16(0xF000)) >> 12 {
//\\
//\\	case uint16(0x0):
//\\		return uint16(oc)
//\\
//\\	case uint16(0x8):
//\\		return uint16(oc) & uint16(0xF00F)
//\\
//\\	case uint16(0xE):
//\\		return uint16(oc) & uint16(0xF0FF)
//\\
//\\	case uint16(0xF):
//\\		return uint16(oc) & uint16(0xF0FF)
//\\
//\\	default:
//\\		return uint16(oc) & uint16(0xF000)
//\\	}
//\\ }
//
// Among all the opcodes, only 4 of them have multiple opcodes that starts with the same nibble (hence the 4 cases (excluding default))
// These are : 0, 8, E and F. Any opcode that doesn't fall in any of these 4 cases are opcodes with an unique nibble 
// hence we can just return the nibble directly ---> uint16(oc) & uint16(0xF000). 
// (The nibble (highest 4 bits) are being returned thanks to F (which is 1111 in hexadecimal))
---------------------------------------------------------------------------------------------------------------------------
/// Fetch opcode \\\
//
// Here's the code :
//
//\\ func (c8 *Chip8) fetchOpcode() {
//\\	c8.COpcode = opcode(uint16(c8.Memory[c8.Pc])<<8 | uint16(c8.Memory[c8.Pc+1]))
//\\	c8.Pc += 2
//\\ }
// 
// Fetching an opcode require to go into the memory and using the program counter to indicate the location of the opcode
// The program counter will start at 0x200 or 512. An opcode is 16 bits long meaning that once we get the first 8 bits,
// we'll shift them to the left (we can since it's a uint16) and get the next 8 bits making it 16 bit long.
// Furthermore, this 16 bit opcode will be converted into the 'opcode' type (made by me) to set the value of
// the current opcode for our chip 8 structure. To finish, we'll increase the program counter by 2 so that the next time
// we fetch, it will get the next opcode and not the same one.
---------------------------------------------------------------------------------------------------------------------------
/// Executing an opcode instruction \\\
//
// Here's the code :
//
//\\ func (c8 *Chip8) executeOpcode() {
//\\	keyInst := c8.COpcode.GetOpcodeInstruction()
//\\	if inst, found := c8.Instructions[keyInst]; found {
//\\		inst()
//\\	}
//\\ }
//
// Firstly, we get the instruction taken from the opcode which we'll use as a key for our Instruction map later.
// Next, we need to check which instruction our variable 'keyInst' currently holds. To find this, we'll need to look
// into the map that we made when initializing the chip8. If the instruction is found, the 'inst' variable will 
// now hold the instruction found and 'found' will be set to true because the instruction has been found. Our if condition
// is checking if found == true (not needed to add the '== true'). If it's true, then we execute the corresponding
// function / instruction
---------------------------------------------------------------------------------------------------------------------------
/// Loading ROM \\\
// The reason that there's to function to load the ROM is because of 2 things :
// 1 - Besides the filename, we'll need other values that are specified in /chip8. Meaning that if you want to call this
// function in /app, you can't because those const don't exist there and extra steps are needed
// 2 - It enables to load other things like fonts without making a seperate function since the steps are the same
// 
// Here's the code :
//
//\\ func (c8 *Chip8) LoadROM(filename string) error {
//\\	return c8.loadFile(filename, MaxCapacityForROM, PCStartAddress, &c8.Memory)
//\\ }
//
//\\ func (c8 *Chip8) loadFile(filename string, maxCapacity int, startAddress int, memory *[TotalMemory]byte) error {
//\\	file, err := os.ReadFile(filename)
//\\	if err != nil {
//\\		return err
//\\	}
//\\
//\\	if len(file) > maxCapacity {
//\\		errSize := "ROM : '" + filename + "' has exceeded the size limitations"
//\\		return errors.New(errSize)
//\\	}
//\\
//\\	copy(memory[startAddress:], file[:])
//\\
//\\	return nil
//\\ }
//
// To load a ROM we first need to read the respective file to get its contents. Once we got what we need we'll 
// verify if the ROM has not exceeding the file size limit. If yes, it will return a new error indicating the error
// To finish, we actually need to load the file contents into the memory by using the copy() function.
// We need to indicate two things, the destination of the copy and the content that we want to copy. The destination
// will be the variable 'memory' which is the chip 8 memory. The content that we want to copy is of course everything
// in the 'file' variable.
---------------------------------------------------------------------------------------------------------------------------

REDO EVERYTHING THIS WAY

/// ToDraw(buffer FrameBuffer) \\\
//
// Location : 
//
// *** (line / block of code in question) ***
// explanation